---
title: Чем функциональные компоненты отличаются от классовых?
date: '2019-03-03'
author: Dan Abramov
origin: https://overreacted.io/how-are-function-components-different-from-classes/
---

Чем функциональный компоненты отличются от классовых?

Некоторое время каночный ответ был такой: классы дают доступ к большему количеству фичей (таких как стейт). С [хуками](https://reactjs.org/docs/hooks-intro.html) это перестало быть правдой.

Возможно вы слышали о том, что один из вариантов более производительный. Который? Многие из тестов производительности [ошибочны](https://medium.com/@dan_abramov/this-benchmark-is-indeed-flawed-c3d6b5b6f97f?source=your_stories_page---------------------------) поэтому я бы был осторожен с [выводами](https://github.com/ryardley/hooks-perf-issues/pull/2). Производительность в первую очередь зависит от того что код делает, а не от вашего выбора между функцией или классом. По нашим наблюдениям разница в производительности незначительна, хотя стратегии по оптимизации немного [разные](https://reactjs.org/docs/hooks-faq.html#are-hooks-slow-because-of-creating-functions-in-render).

В любом случае [мы не рекомендуем](https://reactjs.org/docs/hooks-faq.html#should-i-use-hooks-classes-or-a-mix-of-both) переписывать ваши текущие кмпоненты, только если у вас нет других причин и вы не против стать одним из первых. Хуки по прежнему новинка (как и React в 2014 году), и некоторые “лучшие практики” ещё не получили своего отражения в обучающих курсах.

Так как же нам быть? Есть ли хоть какая-то фундаметальная разница между функциональными компонентами или классами? Конечно они есть - в ментальной модели. **В этом посте, я укажу на самое существенное отличие между ними.** Оно существовало с тех пор как функциональные компоненты были [представлены миру](https://reactjs.org/blog/2015/09/10/react-v0.14-rc1.html#stateless-function-components) в 2015 году, но о нём часто забывают:

>**Функциональные компоненты захватывают значения попавшие в рендер.**

Давайте разберемся, что это значит.

---

**Note: this post isn’t a value judgement of either classes or functions. I’m only describing the difference between these two programming models in React. For questions about adopting functions more widely, refer to the [Hooks FAQ](https://reactjs.org/docs/hooks-faq.html#adoption-strategy).**

**Примечание: Этот пост не является оценочным суждением классов или функций. Я только описываю разницу между этими двумя моделями программирования в React`е. По вопросам связанным с более широком внедрении функций, обратитесь в [Hooks FAQ](https://reactjs.org/docs/hooks-faq.html#adoption-strategy).**

---

Рассмотрим этот компонент:

```jsx
function ProfilePage(props) {
  const showMessage = () => {
    alert('Followed ' + props.user);
  };
  const handleClick = () => {
    setTimeout(showMessage, 3000);
  };
  return (
    <button onClick={handleClick}>Follow</button>
  );
}
```

Он показывает кнопку, которая симулирует сетевой запрос с `setTimeout` и затем показывает алерт. Например, если `props.user` равно `'Dan'`, он покажет `'Followed Dan'` спустя несколько секунд. Достаточно просто.

*(Заметьте, что в этом примере не имеет значения, использовал я стрелочную функцию или обычное декларирование функции. `function handleClick()` будет работать точно так же.)*

Как нам переписать функциональный компонент в классовый? Простая реализация перевода может выглядеть так:

```jsx
class ProfilePage extends React.Component {
  showMessage = () => {
    alert('Followed ' + this.props.user);
  };
  handleClick = () => {
    setTimeout(this.showMessage, 3000);
  };
  render() {
    return <button onClick={this.handleClick}>Follow</button>;
  }
}
```

Принято считать, что эти два фрагмента кода одинаковы. Люди часто меняют один из этих паттернов на другой, не замечая последствий:

![Найдите разницу между двумя версиями](./wtf.gif)

**Тем не менее эти два фрагмента кода немного разные.** Хорошо посмотрите на них. Видите разницу? Лично мне потребовалось время что бы это увидеть.

**Далее будут спойлеры, поэтому вот [дэмо](https://codesandbox.io/s/pjqnl16lm7) если вы хотите сами разобраться.** Оставшаяся часть статьи объясняет разницу и почему это важно.

---

Прежде чем мы продолжим, я бы хотел подчеркнуть что разницу которую я описываю ничего общего с хуками. Пример выще даже не использует хуки!

Речь про отличия между функциями и классами в React`е. Если вы хотите чаще использовать функции в React`е, возможно вы хотите понять их. 

---

**Мы продемонстрируем отличие с помощью бага, который часто встречается в приложениях на React`е.**

Откройте этот **[пример](https://codesandbox.io/s/pjqnl16lm7)** с селектором текущего профиля и двумя имплементациями `ProfilePage` из примера выше - каждый рендерит кнопку с текстом "Follow".

Проделайте эту последовательность действий с обоими кнопками:

1. ***Кликните* на одну из кнопок.
2. **Измените** выбранный профиль прежде чем истекут 3 секунды.
3. **Прочитайте** текст в алерте.

Вы заметите своеобразную разницу:

* С **функцией** `ProfilePage`, кликая "Follow" на профиль Dan и затем переходя к Sophie, вы получите алерт с `'Followed Dan'`.

* С **классом** `ProfilePage` алерт будет содержать надпись `'Followed Sophie'`:

![Демонстрация шагов](./bug.gif)

---


В этом примере, первое поведение является корректны. **Если я выберу профиль и затем перейду к другому, мой кмопонент не запутается с тем, кого я выбрал.** Но очевидно, что реализация классового компонета багованная.

*(Вы определённо должны [зафоловить Sophie](https://mobile.twitter.com/sophiebits).)*

---

Почему нащ классовый компонент ведёт себя таким образом?

Давайте внимательнее посомтрим на метод `showMessage` в нашем классе:

```jsx{3}
class ProfilePage extends React.Component {
  showMessage = () => {
    alert('Followed ' + this.props.user);
  };
```

Этот классовый метод считывает `this.props.user`. Пропсы иммутабельны в React`е поэтому они никогда не могут быть изменены. **Тем не менее, `this` *является* и всегда был мутабельным.**

На самом деле, это вся цель `this` в классах. React сам мутирует `this` со временем, поэточто бы вы могли прочитать свежую версию в `render` и методах жизненного цикла.

Поэтому если наш компонент произведёт ре-рендер, пока запрос ещё не отработал, `this.props` поменяюся. Метод `showMessage` прочитает `user` из “совсем новых” `props`.

Это демонстрирует интересную особенность природы пользовательских интерфейсов. Если мы говорим, что концептуально UI - это функция текущего состояния приложения, **тогда и обработчики событий являются частью результата рендера - так же как и визуальный вывод.** Наше событие принадлежит конкретному рендеру с конкретными пропсами и стейтом.

Но использование timeout, чей колбэк в свою очередь читает `this.props` ломает эту связь. Наш колбэк из метода `showMessage` не связан с каким-либо конкретным рендером и поэтому он теряет нужные нампропсы. Считывание из `this` обрывает эту связь.

---

**Давайте представим, что функциональные компоненты никогда не существовали.** Как бы мы решили проблему?

Мы бы хотели как-то восстановить связь между `render` с корректными пропсами и колбэком из `showMessage`, который их читает. Где-то по пути `props` теряются.

Один из способов будет прочитать `this.props` на ранней стадии события и затем явно передать их в колбэк таймаута.


```jsx{2,7}
class ProfilePage extends React.Component {
  showMessage = (user) => {
    alert('Followed ' + user);
  };

  handleClick = () => {
    const {user} = this.props;
    setTimeout(() => this.showMessage(user), 3000);
  };

  render() {
    return <button onClick={this.handleClick}>Follow</button>;
  }
}
```

Perhaps, we could *bind* the methods in the constructor?

Это [работает](https://codesandbox.io/s/3q737pw8lq). Тем не менее, этот подход делает код значительнее многословнее и со времен более подверженным ошибкам. Что если нам нужно более одной пропсы? Что если нам нужен доступ к стейту? **Если `showMessage` вызывает другой метод `this.props.something` или `this.state.something` мы столкнёмся с той же самой проблемой.** Поэтому мы должны передевать `this.props` и `this.state` аргументами в каждый метод вызванный из `showMessage`.

Поступая таким образом, мы ломаем эргономику обычно предостовляемую классом. К тому же это сложно запомнить или усвоить, вот почему люди часто соглашаются на баги.

Подобным образом, встраивание `alert` внутрь `handleClick` не решает более серьёзной проблемы. Мы хотим структуризовать код таким образом, что бы мы могли разбивать код на большее количество методов, *но* так же могли читать пропсы и стейт, так что бы они соответствовали нужному рендеру. **Эта проблема не характерна только для React`а, вы можете воспроизвести  её в любой UI библиотеки, которая складывает данные в мутабельный объект, подобный `this`.**

Возможно, мы могли бы *привязать контекст метода* в конструкторе?

```jsx{4-5}
class ProfilePage extends React.Component {
  constructor(props) {
    super(props);
    this.showMessage = this.showMessage.bind(this);
    this.handleClick = this.handleClick.bind(this);
  }

  showMessage() {
    alert('Followed ' + this.props.user);
  }

  handleClick() {
    setTimeout(this.showMessage, 3000);
  }

  render() {
    return <button onClick={this.handleClick}>Follow</button>;
  }
}
```

Нет, это ничего не исправит. Помните, что проблема в том, что мы читаем из `this.props` слишком поздно - не в синтаксе, который мы используем! **Однако, проблема уйдёт если мы полностью положимся на замыкания в JavaScript.**

Замыкания редко используют, потому что [тяжело](https://wsvincent.com/javascript-closure-settimeout-for-loop/) думать о значении, которое со временем может быть мутировано. Но в React`е пропсы и стейт иммутабельны! (Как минимум это настойчивая рекомендация.) Что в свою очередь убирает серьёзную проблему с замыканиями.

Это значит, что если вы сделаете замыкание с пропсами или стейтом из рендера, вы сможете расчитывать что они остануться прежними:

```jsx{3,4,9}
class ProfilePage extends React.Component {
  render() {
    // Capture the props!
    const props = this.props;

    // Note: we are *inside render*.
    // These aren't class methods.
    const showMessage = () => {
      alert('Followed ' + props.user);
    };

    const handleClick = () => {
      setTimeout(showMessage, 3000);
    };

    return <button onClick={handleClick}>Follow</button>;
  }
}
```


** Вы “поймали” пропсы во время рендера:**

![Поймали покемона](./pokemon.gif)

В этом случае любой код внутри (включая `showMessage`) гарантировано увидит пропсы для этого конкретного рендера. React больше не отодвигает нашу цель.

**Внутрь мы можем добоавить столько много функций, сколько захотим и они все будут использовать схваченные пропсы и стейт.** Замыкания приходят на помощь!

---

The [example above](https://codesandbox.io/s/oqxy9m7om5) is correct but it looks odd. What’s the point of having a class if you define functions inside `render` instead of using class methods?

Indeed, we can simplify the code by removing the class “shell” around it:


[Пример выше](https://codesandbox.io/s/oqxy9m7om5) корректен, но смотрится странно. Какой смысл в классе если вы определяете функции внутри `render` вместо использования классовых методов?

На самом деле, мы можем упростить код, удалив классовую “оболочку” вокруг него:

```jsx
function ProfilePage(props) {
  const showMessage = () => {
    alert('Followed ' + props.user);
  };

  const handleClick = () => {
    setTimeout(showMessage, 3000);
  };

  return (
    <button onClick={handleClick}>Follow</button>
  );
}
```

Так же как и раньше `props` попрежнему захватываются - React передаёт их как аргумент. **В отличии от `this`, объект `props` сам по себе никогда не изменяется React`ом.**


Это станет более очевидно, если вы деструктуризируете `props` в определении функции:

```jsx{1,3}
function ProfilePage({ user }) {
  const showMessage = () => {
    alert('Followed ' + user);
  };

  const handleClick = () => {
    setTimeout(showMessage, 3000);
  };

  return (
    <button onClick={handleClick}>Follow</button>
  );
}
```

Когда родительский компонент рендерит `ProfilePage` с разными пропсами, React снова вызовет функцию `ProfilePage`. Но обработчик событий, по которому мы уже кликнули принадлежит предыдущему рендеру с его собственным значением для `user` и коллбэком `showMessage` который читает его.

Вот почему в варианте с функцией [в этом дэмо](https://codesandbox.io/s/pjqnl16lm7) клик "Follow" по профилю Sophie и потом изменение профиля на Sunil вывдет алерт с `'Followed Sophie'`:

![Демо корректного поведения](./fix.gif)

Это поведение корректно. *(Возможно вы захотите также [подписаться на Sunil](https://mobile.twitter.com/threepointone)!)*

---

Теперь мы поняли большую разницу между функциями и классами в React`е:

>**Функциональные компоненты фиксируют значения из рендера.**

**С хуками, этот же принцип применяется к стейту.** Рассмотрим этот пример:

```jsx
function MessageThread() {
  const [message, setMessage] = useState('');

  const showMessage = () => {
    alert('You said: ' + message);
  };

  const handleSendClick = () => {
    setTimeout(showMessage, 3000);
  };

  const handleMessageChange = (e) => {
    setMessage(e.target.value);
  };

  return (
    <>
      <input value={message} onChange={handleMessageChange} />
      <button onClick={handleSendClick}>Send</button>
    </>
  );
}
```

(Вот [дэмо](https://codesandbox.io/s/93m5mz9w24).)

Хоть это и не лучший UI для мессенджера, но он демонстрирует нам тот же смысл: если я отправлю сообщение, комонент не запутается с тем, какое именно сообщение надо отправить. Значение `message` из этого функционального компонента захватывает состояние “принадлежащее” рендеру вернувшему обработчик событиый вызванный браузером. Поэтому `message` будет равно значнию в инпуте, когда я кликнул “Send”.

---

И так мы знаем, что функции в React`е по умолчанию захватывают пропсы и стейт. **Но что если мы *хотим* считывать последние пропсы или стейт, которые не принадлежат к этому конкретному рендеру?** Что если мы хотим [“читать их из будущего”](https://dev.to/scastiel/react-hooks-get-the-current-state-back-to-the-future-3op2)?

В классах вы делаете это, когда считываете `this.props` или `this.state` потому, что `this` само по себе иммутабельно. React мутирует его. В функциональных компонентах вы можете иметь мутабельное значение, которое будет общим для всех рендеров компонента. Оно называется “ref”:

```jsx
function MyComponent() {
  const ref = useRef(null);
  // You can read or write `ref.current`.
  // ...
}
```

Но вы сами должны управлять им.

Реф [играет ту же роль](https://reactjs.org/docs/hooks-faq.html#is-there-something-like-instance-variables) что и поле экземпляра. 
Это лазейка в императивный мир. Возможно, вы знакомы с “DOM refs”, но концепция гораздо шире. Это просто коробка, в которую вы можете положить что-нибудь.

Даже визуально `this.something` выглядет как зеркало для `this.something`. Они представляют тот же концепт.

По умолчанию, React не создаёт рефы для последних пропсов или стейта в функциональном компоненте. В большинстве случаев вам они не нужны и было бы напрасной тратой времени присваивать их. Но если хотите, вы можете отслеживать значение вручную:

```jsx{3,6,15}
function MessageThread() {
  const [message, setMessage] = useState('');
  const latestMessage = useRef('');

  const showMessage = () => {
    alert('You said: ' + latestMessage.current);
  };

  const handleSendClick = () => {
    setTimeout(showMessage, 3000);
  };

  const handleMessageChange = (e) => {
    setMessage(e.target.value);
    latestMessage.current = e.target.value;
  };
```

Если мы прочиатем `message` в `showMessage`, мы увидим значение в момент нажатия кноки Send. Но когда мы прочитаем `latestMessage.current`, мы получим последнее значение - даже если мы продолжим печатать после того как была нажата кнопка Send.

Вы можете сравнить [два](https://codesandbox.io/s/93m5mz9w24) [дэмо](https://codesandbox.io/s/ox200vw8k9) что бы самим понять разницу. Реф - это путь к отказу от консистентности рендера и иногда может быть удобен.

Generally, you should avoid reading or setting refs *during* rendering because they’re mutable. We want to keep the rendering predictable. **However, if we want to get the latest value of a particular prop or state, it can be annoying to update the ref manually.** We could automate it by using an effect:



Обычно вам лучше избегать чтения или установки рефов *во время* рендера, потому что они мутабельны. Мы хотим сохранить рендер предсказуемым. **Однако, если мы хотим получить последнее значение конкретной пропсы или стейта, процесс ручного обновление рефа - может стать достаточно надоедливым.** Мы может автоматизировать его, используя эффект:

```jsx{4-8,11}
function MessageThread() {
  const [message, setMessage] = useState('');

  // Keep track of the latest value.
  const latestMessage = useRef('');
  useEffect(() => {
    latestMessage.current = message;
  });

  const showMessage = () => {
    alert('You said: ' + latestMessage.current);
  };
```

(Вот [дэмо](https://codesandbox.io/s/yqmnz7xy8x).)

Мы делаем присвоение *внутри* эффекта, поэтому значение рефа изменится только после того как DOM обновится. Это гарантирует, что наша мутация не сломаем такие фичи как [Time Slicing и Suspense](https://reactjs.org/blog/2018/03/01/sneak-peek-beyond-react-16.html) которые полагаются на прерывистый рендеринг.

Не требуется часто использовать реф таким образом. **Захватывать пропсы или стейт обычно лучше по умолчанию.** Но это может быть удобно когда имеете дело с [императивными API](/making-setinterval-declarative-with-react-hooks/), например интервалы или подписки. Помните, что таким образом вы можете отследить *любое* значение - пропсу, переменную из стейта, целиком весь объект с пропсами или даже функцию.

Этот паттерн может быть удобен для оптимизаций - например, когда идентификатор `useCallback` меняется слишком часто. Но [использование редьюсера](https://reactjs.org/docs/hooks-faq.html#how-to-avoid-passing-callbacks-down) часто является [лучшим решением](https://github.com/ryardley/hooks-perf-issues/pull/3). (Тема будущих постов!)

---

В этом посте мы посмотрели на распрастранённый анти-паттерн в классах и как замыканию помогают нам исправить его. Но вы могли заметить, что когда вы пытаетесь оптимизировать хуки определяя массив зависимостей, вы можете столкнуться с багами из-за устаревших замыканий. Значит ли это, что замыкания - проблема? Я так не думаю.

Как мы видели выше, замыкания помогают нам *исправить* неявные проблемы, которые сложно заметить. Похожим образом они упрощают написание кода, который корректно работает в [Concurrent режиме](https://reactjs.org/blog/2018/03/01/sneak-peek-beyond-react-16.html). Это возможно потому, что логика внутри компонента замыкается над нужными пропсами и стейтом, с которыми он отрендерился.

Во всех случаях, которые мне приходилось видеть, **проблемы с “устаревишими замыканиями” происходили из-за ошибочного предположения, что “функции не изменяются” или что “пропсы всегда те же самые”.** Это не так, что как я надеюсь, этот пост помог прояснить.

Функции замыкаются с их пропсами и стейтом, поэтому их идентичность так же важна. Это не баг а фича функциональных компонентов. Для примера, функции не должны быть исключены из “массива зависимостей” для `useEffect` или `useCallback`. (Обычно правильный фикс - это использовать `useReducer` или `useRef` из примера выше - скоро мы задокумнетируем как правильно выбрать между ними.)

Когда мы пишем большую часть кода в React`е пишем на функциях, нам нужно быть готовым к [оптимизации кода]https://github.com/ryardley/hooks-perf-issues/pull/3) и [что значения могут со временем меняться](https://github.com/facebook/react/issues/14920).

Как [выразился Фредерик](https://mobile.twitter.com/EphemeralCircle/status/1099095063223812096):

>Лучшее ментальное правило о хуках, которое я находил это ”пишите код так, как будто любое значение может изменится в любой момент”.

Функции не исключение из этого правила. Нужно некоторое время, что бы это стало общим знанием в учебных материалах по React`у. Так же потребуется некоторая корректировка мышления привыкшего к классам. Но я надеюсь, что эта статья поможет вам увидеть это свежим взглядом.

Функции в React`е всегда схватывают их значения - и теперь мы знаем почему.

![Улыбающийся пикачу](./pikachu.gif)

Они совсем другие покемоны.
