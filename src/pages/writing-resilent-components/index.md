---
title: Написание гибких компонентов
date: '2019-03-16'
author: Dan Abramov
origin: https://overreacted.io/writing-resilient-components/
shortDescription: Четыре принципа, что бы направить в правильную сторону
---

Когда люди начинают изучать React, они часто спрашивают о стайлгайде.
С одной стороны - это хорошая идея иметь последовательные правила по всему проекту, но с другой стороны, многие из этих правил произвольны и поэтому React не имеет сторого мнения на их счёт.

Вы можете использовать разные системы типиизации, предпочитать объявление функций (function declarations) или стрелочные функции, распологать ваши пропсы в алфавитном порядке или в любом другом порядке, который вам нравится. 

Эта гибкость позволяет [интегрировать React](https://reactjs.org/docs/add-react-to-a-website.html) в проекты с уже существующими соглашениями в нутри него. Но так же это порождает бесконечные споры.

**_Существуют_ важные принципы проектирования, которых каждый компонент должен придерживаться. Но я не думаю, что стайлгайды хорошо охватывают эти принципы. Сначала мы поговорим о стайлгайдах затем [взглянем на принципы, которые действительно полезны](#%D0%BD%D0%B0%D0%BF%D0%B8%D1%81%D0%B0%D0%BD%D0%B8%D0%B5-%D0%B3%D0%B8%D0%B1%D0%BA%D0%B8%D1%85-%D0%BA%D0%BE%D0%BC%D0%BF%D0%BE%D0%BD%D0%B5%D0%BD%D1%82%D0%BE%D0%B2).**

---

## Не отвлекайтесь на воображаемые проблемы

Прежде чем мы поговорим о принципах разработки компонентов, я хочу сказать пару слов о стайлгайдах. Это не самое распространённое мнение, но кто-то должен его озвучить!

В JavaScript сообществе, есть несколько строгих и упрямых стайлгайдов навязываемых линтером. Моё личное наблюдение: линтеры склонны создавать больше сложностей, чем они решают. Я не смогу сощитать как много раз кто-то показывал мне абсолютно валидный код и говорил при этом: "React жалуется на это", но на самом деле причина была в конфиге их линтера! Это приводит к трём проблемам:

* Люди привыкли видеть в линтерах скорее **черезмерно надоедливого надсмоторщика** чем не полезный инструмент. Полезные замечания тонут среди советов о стиле кода. Как результат, люди не просматривают сообщения от линтера во время дебага и пропускают действительно полезные заметки. Дополнительно, люди которые меньше привыкли писать на JavaScript (например, дизайнеры) будут испытывать ещё больше трудностей при работы с кодом. 

* Люди не учаться **различать валидное и невалидное применение** конкретного паттерна. Например, есть популярное правило, которое запрещает вызов `setState` внутри `componentDidMount`. Но если бы этот паттерн всегда был бы "плох", React по-просту не позволял его использовать. Есть случаи, когда такой паттер оправдан, например вам нужно измерить DOM элемент для размещения около него тултипа. Я видел как люди обходят это правило добавляя `setTimeout`, который абсолютно не учитывает вышесказанное.

* В итоге, люди принимают эту насаждённую линтерами установку и получают навязанное мнение о вещах которые **не несут существенной разницы** но легко сканируемы в коде. "Вы использовали декларирование функций, но в **нашем** проекте мы используем стрелочные функции". Всякий раз, когда я испытываю сильное чувство связанное с соблюдением таких правил, глубокий взгляд показывает, что я вложил эмоциональные усилия в это правило и изо всех сил стараюсь его отпустить. Это заманивает меня в ловушку ложного чувства выполненного долга без действительного улучшения моего кода.

Говорю ли я, что нам нужно прекратить пользоваться линтерами? Вовсе нет!

**С хорошим конфигом, линтер отличная вещь для предотвращения багов.** Но если линтер будет сильно фокусируется на *стиле* он будет вас отвлекать.

---

## Наведи порядок в линтере как Мари Кондо

Вот что я предлагаю вам сделать в понедельник. Собиретесь всей командой на полтора часа, пройдитесь по всем включённым правилам линтера в конфиге вашего проекта и спросите себя: *"Помогало ли это правило поймать баг?"* Если нет, *выключайте его.* (Вы так же можете начать с чистого листа с [`eslint-config-react-app`](https://www.npmjs.com/package/eslint-config-react-app) у этого конфига нет правил по стилям.)

Как минимум ваша команда должна иметь процесс, который позволит ей удалять правила, которые вызывают разногласия. Не предполагайте, что все что вы или кто-то другой добавили в конфиг линтера год назад, является "лучшей практикой". Ставьте это под вопрос и ищите ответы. Не позволяйте кому-либо говорить, что вы не достаточно умны, что бы выбирать настройки для вашего линтера.

**Но что на счёт форматирования?** Используйте [Prettier](https://prettier.io/) и забудьте о стилевых замечаниях. Вам не нужен инструмент, который будет кричать на вас за лишний пробел, если это может пофиксить за вас другой инструмент. Используйте линтер для поиска *багов*, не для навязывания *э с т е т и к и*.

Конечно есть аспекты в код-стайле, которые напрямую не относятся к форматированию, но всё равно могут быть раздражающими когда непоследовательно встречаются по всему проекту.

Тем не менее, многие из них слишком незначительны что бы отлавливать их с помощью линтера. Вот почему важно **выстроить доверие** между членами команды и делиться полезными знаниями в форме вики-страницы или короткого гайда.

Не всё стоит автоматизации! Знания полученные из **фактического чтения** в таком гайде могут быть более ценными чем следование "правилам".

**Но если следование строгим правилам отвлекает, что тогда по настоящему важно?**

Это тема этого поста.

---

## Написание гибких компонентов

Количество отступов или сортирование импортов в алфавитном порядке не смогут пофиксить сломанную архитектуру. И так, вместо того что бы фокусироваться на том как *выглядет* код, я буду большее внимание уделять тому как этот код *работает*. Вот несколько прицнипов, которые я нахожу очень полезными: 

1. **[Не останавливайте поток данных](#%D0%BF%D1%80%D0%B8%D0%BD%D1%86%D0%B8%D0%BF-1-%D0%BD%D0%B5-%D0%BE%D1%81%D1%82%D0%B0%D0%BD%D0%B0%D0%B2%D0%BB%D0%B8%D0%B2%D0%B0%D0%B9%D1%82%D0%B5-%D0%BF%D0%BE%D1%82%D0%BE%D0%BA-%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85)**
2. **[Всегда будьте готовы к ререндеру](#%D0%BF%D1%80%D0%B8%D0%BD%D1%86%D0%B8%D0%BF-2-%D0%B2%D1%81%D0%B5%D0%B3%D0%B4%D0%B0-%D0%B1%D1%83%D0%B4%D1%8C%D1%82%D0%B5-%D0%B3%D0%BE%D1%82%D0%BE%D0%B2%D1%8B-%D0%BA-%D1%80%D0%B5%D0%BD%D0%B4%D0%B5%D1%80%D1%83)**
3. **[Компонент не должен быть синглтоном](#%D0%BF%D1%80%D0%B8%D0%BD%D1%86%D0%B8%D0%BF-3-%D0%BA%D0%BE%D0%BC%D0%BF%D0%BE%D0%BD%D0%B5%D0%BD%D1%82-%D0%BD%D0%B5-%D0%B4%D0%BE%D0%BB%D0%B6%D0%B5%D0%BD-%D0%B1%D1%8B%D1%82%D1%8C-%D1%81%D0%B8%D0%BD%D0%B3%D0%BB%D1%82%D0%BE%D0%BD%D0%BE%D0%BC)**
4. **[Держите локальный стейт изолированным](#%D0%BF%D1%80%D0%B8%D0%BD%D1%86%D0%B8%D0%BF-4-%D0%B4%D0%B5%D1%80%D0%B6%D0%B8%D1%82%D0%B5-%D0%BB%D0%BE%D0%BA%D0%B0%D0%BB%D1%8C%D0%BD%D1%8B%D0%B9-%D1%81%D1%82%D0%B5%D0%B9%D1%82-%D0%B8%D0%B7%D0%BE%D0%BB%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D1%8B%D0%BC)**

Даже если если вы не используете React, вы скорее всего откроете для себе те же самые принципы путём проб и ошибок, для любой UI компонентной модели с однонаправленным потоком данных.

---

## Принцип 1: Не останавливайте поток данных

### Не останавливайте поток данных при рендере


Когда кто-либо использует ваш компонент, они ожидают что смогут передовать различные пропсы и что этот компонент отобразит эти изменения:

```jsx
// isOk  может относится к локальному стейту и может измениться в любое время
<Button color={isOk ? 'blue' : 'red'} />
```

В общем, так работает React по дефолту. Если вы используете свойство `color` внутри компонента `Button`, вы увидите значение переданное сверху для этого рендера: 

```jsx
function Button({ color, children }) {
  return (
    // ✅ `color` всегда актуальное свойство!
    <button className={'Button-' + color}>
      {children}
    </button>
  );
}
```

Тем не мение, общая ошибка при изучении React`а - копировать пропсы в стейт.


```jsx{3,6}
class Button extends React.Component {
  state = {
    color: this.props.color
  };
  render() {
    const { color } = this.state; // 🔴 `color` устарел!
    return (
      <button className={'Button-' + color}>
        {this.props.children}
      </button>
    );
  }
}
```

Возможно по началу это кажется более интуитивным, особенно если вы использовали классы вне React`а. **Тем не менее, копируя свойство в стейт вы игнорируете все его будущие обновления**

```jsx
// 🔴 Больше не будет работать при обновлениях с вариантом выше
<Button color={isOk ? 'blue' : 'red'} />
```

В том редком случае, когда вы *намеренно* делаете это, убедитесь что это вы назвали это свойство `initialColor` или `defaultColor`, что бы было понятно, что все дальнейшие изменения будут игнорироваться.

Но обычно вы хотите только **прочитать свойства напрямую в вашем компоненте** и избегаете копирование свойств (или чего-то другово вычесленного из пропсов) в стейт.

```jsx
function Button({ color, children }) {
  return (
    // ✅ `color` всегда актуально!
    <button className={'Button-' + color}>
      {children}
    </button>
  );
}
```

----

Вычисление значений - ещё одна причина, по которой люди иногда пытаются копировать пропсы в стейт. Например, представьте, что мы определили цвет *текста кнопки*, основываясь на дорогом вычеслении с `color` как аргументом:

```jsx{3,9}
class Button extends React.Component {
  state = {
    textColor: slowlyCalculateTextColor(this.props.color)
  };
  render() {
    return (
      <button className={
        'Button-' + this.props.color +
        ' Button-text-' + this.state.textColor // 🔴 Не актуально про обновлении `color`
      }>
        {this.props.children}
      </button>
    );
  }
}
```

Этот компонет багованный потому, что он не вычисляет `this.state.textColor` при изменении свойства `color`.
Самый простой способ исправить это: перенести вычисление `textColor` в `render` и превратить этот компонент в `PureComponent`:

```jsx{1,3}
class Button extends React.PureComponent {
  render() {
    const textColor = slowlyCalculateTextColor(this.props.color);
    return (
      <button className={
        'Button-' + this.props.color +
        ' Button-text-' + textColor // ✅ Актуально
      }>
        {this.props.children}
      </button>
    );
  }
}
```

Проблема решена! Теперь если свойство изменится, мы пересчитаем значение `textColor`, но мы избежим дорогово вычисления при тех же самых значениях.

Но возможно, мы захотим оптимизировать этот код ещё больше. Что если в компоненте будет изменяться свойство `children`? В этом случае, не самой лучшей идеей будет вычислять `textColor`. Нашей второй попыткой будет вызов вычисления в `componentDidUpdate`:

```jsx{5-12}
class Button extends React.Component {
  state = {
    textColor: slowlyCalculateTextColor(this.props.color)
  };
  componentDidUpdate(prevProps) {
    if (prevProps.color !== this.props.color) {
      // 😔 Дополнительный ре-рендер при каждом апдейте
      this.setState({
        textColor: slowlyCalculateTextColor(this.props.color),
      });
    }
  }
  render() {
    return (
      <button className={
        'Button-' + this.props.color +
        ' Button-text-' + this.state.textColor // ✅ Свежее при финальном рендере
      }>
        {this.props.children}
      </button>
    );
  }
}
```

Но это будет означать, что наш компонент будет делать второй ре-рендер после каждого изменения. Это неидеальный вариант,только если мы не оптимизируем его.

Для этого вы можете использовать легаси метод жизненного цикла `componentWillReceiveProps`. Люди часто пишут в нём и сайд-эффекты. Это в свою очередь часто вызывает проблемы для нового Concurrent Rendering [такие фичи как Time Slicing и Suspense](https://reactjs.org/blog/2018/03/01/sneak-peek-beyond-react-16.html), а более "безопасный" метод `getDerivedStateFromProps` делает неуклюжим.

Давайте на секунду вернемся назад. Фактически нам нужна [*мемоизация*](https://en.wikipedia.org/wiki/Memoization). У нас есть некие инпуты и мы не хотим вычислять значения заново, если только не меняются сами инпуты.

С классами вы можете использовать [хелпер](https://reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html#what-about-memoization) для мемоизации. Но использованиее хуков было бы большим шагом вперёд, давая вам встроенный метод для запоминания дорогих вычислений:

```jsx{2-5}
function Button({ color, children }) {
  const textColor = useMemo(
    () => slowlyCalculateTextColor(color),
    [color] // ✅ Не пересчитывать до изменения `color`
  );
  return (
    <button className={'Button-' + color + ' Button-text-' + textColor}>
      {children}
    </button>
  );
}
```

Это весь код который вам потребуется!

В class-компоненте вы можете использовать такой хелпер [`memoize-one`](https://github.com/alexreardon/memoize-one). В функциональном компоненте, хук `useMemo` даёт вам такой же функционал.

Теперь мы видим, что **даже оптимизация дорогих вычислений не будет хорошей причиной для копирования пропсов в стейт.** Наш конечный результат в рендере должен реагировать на изменения в пропсах.

---

### Не останавливайте поток данных в сайд эффектах

До сих пор мы говорили о том как быть последовательными с результатом рендера при изменении пропсов. Избегание копирования пропсов в стейт - часть этого. Тем не менее, так же важно что **сайд эффекты (например, загрузка данных) тоже ялвяются частью потока данных**.

Рассмотрим такой React компонет:

```jsx{5-7}
class SearchResults extends React.Component {
  state = {
    data: null
  };
  componentDidMount() {
    this.fetchResults();
  }
  fetchResults() {
    const url = this.getFetchUrl();
    // Получаем данные...
  }
  getFetchUrl() {
    return 'http://myapi/results?query' + this.props.query;
  }
  render() {
    // ...
  }
}
```

Многие компоненты выглядят схожим образом, но если мы посмотрим внимательнее мы заметим баг. Метод `fetchResults` использует свойство `query` для загрузки данных:

```jsx{2}
  getFetchUrl() {
    return 'http://myapi/results?query' + this.props.query;
  }
```

Но что если свойство `query` изменится? В нашем компоненте ничего не произойдёт. *Это значит, что сайд-эффекты нашего компонента не обращают внимаения на изменения его пропсов*. Это довольно распростронённый источник багов в React приложениях.

Что бы исправить наш компонент, нам нужно:

* Посмотрим на `componentDidMount` и все методы вызванные им.
	- В нашем примере это `fetchResults` и `getFetchUrl`.
* Выписать все пропсы и свойства стейта, используемые этими методами.
	- В нашем примере это `this.props.query`.
* Убедиться, что когда эти свойства изменяются, мы перезапускаем сайд-эффект.
	- Мы можем сделать это добавив метод `componentDidUpdate`.

```jsx{8-12,18}
class SearchResults extends React.Component {
  state = {
    data: null
  };
  componentDidMount() {
    this.fetchResults();
  }
  componentDidUpdate(prevProps) {
    if (prevProps.query !== this.props.query) { // ✅ Загрузить данные заново при изменении
      this.fetchResults();
    }
  }
  fetchResults() {
    const url = this.getFetchUrl();
    // Do the fetching...
  }
  getFetchUrl() {
    return 'http://myapi/results?query' + this.props.query; // ✅ Изменения учитываются
  }
  render() {
    // ...
  }
}
```

 Теперь наш код отзывчив ко всем изменениям пропсов, даже для сайд-эффектов.

 Однако, может быть затруднительным - не сломать это снова. Допустим мы можем добавить `currentPage` в локальный  стейт и использовать его в `getFetchUrl`:

```jsx{4,21}
class SearchResults extends React.Component {
  state = {
    data: null,
    currentPage: 0,
  };
  componentDidMount() {
    this.fetchResults();
  }
  componentDidUpdate(prevProps) {
    if (prevProps.query !== this.props.query) {
      this.fetchResults();
    }
  }
  fetchResults() {
    const url = this.getFetchUrl();
    // Do the fetching...
  }
  getFetchUrl() {
    return (
      'http://myapi/results?query' + this.props.query +
      '&page=' + this.state.currentPage // 🔴 Изменения будут проигнорированы
    );
  }
  render() {
    // ...
  }
}
```

Увы, в нашем коде снова появился баг, наш сайд-эффект игнорирует изменения в `currentPage`.

**Пропсы и стейт - части потока данных в React`е. Рендер и сайд-эффект должны отображать изменения в этом потоке данных, не игнорируя их!**

Что бы исправить наш код, повторим вышеуказанные шаги:

* Посмотрим на `componentDidMount` и все методы вызванные им.
	- В нашем примере это `fetchResults` и `getFetchUrl`.
* Выписать все пропсы и свойства стейта, используемые этими методами.
	- В нашем примере это `this.props.query`**и `this.state.currentPage`**.
* Убедиться, что когда эти свойства изменяются, мы перезапускаем сайд-эффект.
	- Мы можем сделать это добавив метод `componentDidUpdate`.

Давайте исправим наш компонент, так что бы он мог обработать изменения `currentPage`:

```jsx{11,24}
class SearchResults extends React.Component {
  state = {
    data: null,
    currentPage: 0,
  };
  componentDidMount() {
    this.fetchResults();
  }
  componentDidUpdate(prevProps, prevState) {
    if (
      prevState.currentPage !== this.state.currentPage || // ✅ подгружать данные при изменении пропсов
      prevProps.query !== this.props.query
    ) {
      this.fetchResults();
    }
  }
  fetchResults() {
    const url = this.getFetchUrl();
    // Do the fetching...
  }
  getFetchUrl() {
    return (
      'http://myapi/results?query' + this.props.query +
      '&page=' + this.state.currentPage // ✅ Изменения обрабатываются
    );
  }
  render() {
    // ...
  }
}
```

**Было бы неплохо если бы мы могли автоматически отлавливать такие ошибки?** Разве это не то с чем бы нам мог помочь линтер?

---

К сожалению, такая автоматическая проверка компонента написанная через классы слишком сложна. Любой метод может быть вызван любым другим. Cтатический анализ вызванный из `componentDidMount` и `componentDidUpdate` череват ложно положительными результатами.

Тем не менее, *можно* разработать такое API которое *сможет* статически анализировать целостность. Пример такого API - [React `useEffect` Hook](/a-complete-guide-to-useeffect/):

```jsx{13-14,19}
function SearchResults({ query }) {
  const [data, setData] = useState(null);
  const [currentPage, setCurrentPage] = useState(0);

  useEffect(() => {
    function fetchResults() {
      const url = getFetchUrl();
      // Подгрузить данные...
    }

    function getFetchUrl() {
      return (
        'http://myapi/results?query' + query +
        '&page=' + currentPage
      );
    }

    fetchResults();
  }, [currentPage, query]); // ✅ Подгружаем данные при изменениях

  // ...
}
```

Мы помещаем логику *внутрь* эффекта и это упрощает понимание того *от каких значений из потока данных* она зависит. Такие значения мы называем "зависимостями", и в нашем примере таковыми являются `[currentPage, query]`.

Заметьте, что такой массив “зависимостей эффекта” вовсе не новый концепт. В классах мы должны были искать такие “зависимости” во всех вызовах метода. API `useEffect` только делает этот концепт более явным.

Это в свою очередь позволяет нам валидировать зависимости автоматически:

![Demo of exhaustive-deps lint rule](./useeffect.gif)

*(Это демо нового рекомендуемого правила для линтера `exhaustive-deps`, которое является частью `eslint-plugin-react-hooks`. Вскоре оно будет включено в Create React App.)*

**Заметьте, что важно внимательно относиться ко всем изменениям пропсов и стейта для сайд-эффектов, вне зависимости пишите вы комонет как класс или как функцию.**

С API классов вы должны думать о целостности сами и убедиться в том, что определённое изменения по отоношению к каждому соответствующему свойству или стейту обрабатываются в `componentDidUpdate`. Иначе, ваш компонент не будет гибким к изменениям пропсов и стейта. Это проблема не является специфичной только для React`а, она касается любой UI библиотеки, которая позволяет вам обрабатывать “создание” and “обновление” отдельно.

**`useEffect` API переворачивает наше обычное представление об обновлении компонента, поощряя последовательность.** [По началу это может казаться вам непривычным](/a-complete-guide-to-useeffect/), но как результат ваши компоненты будут более гибкими к изменениям в логике. По причине того, что “зависимости” теперь стали более явными, мы можем *верифицировать* консистентность эффекта используя правило линтера. Мы используем правила линтера для отловли багов!

---

### Не останавливайте поток данных в оптимизации

Есть ещё один случай, когда вы можете случайно проигнорировать изменения в пропсах. Эта ошибка может появиться когда вы оптимизируете ваш компонент вручную.

Заметьте, что подходы к оптимизации с поверхностным сравнением (`PureComponent` и `React.memo`) по дефолту безопасны.

**Но если вы попытаетесь “оптимизировать” компонент написанием  своего сравнения, вы можете забыть сравнить фунции, передаваемые через пропсы:**

```jsx{2-5,7}
class Button extends React.Component {
  shouldComponentUpdate(prevProps) {
    // 🔴 Не сравниевает this.props.onClick 
    return this.props.color !== prevProps.color;
  }
  render() {
    const onClick = this.props.onClick; // 🔴 Не отреагирует на изменения
    const textColor = slowlyCalculateTextColor(this.props.color);
    return (
      <button
        onClick={onClick}
        className={'Button-' + this.props.color + ' Button-text-' + textColor}>
        {this.props.children}
      </button>
    );
  }
}
```

Легко пропустить такую ошибку, потому что передача *методов* вниз к потомку - это то что вы часто делаете с классами, так что в любом случае метод будет иметь такую же идентичность:

```jsx{2-4,9-11}
class MyForm extends React.Component {
  handleClick = () => { // ✅ Всегда одна и та же функция
    // Сделать что-либо
  }
  render() {
    return (
      <>
        <h1>Hello!</h1>
        <Button color='green' onClick={this.handleClick}>
          Press me
        </Button>
      </>
    )
  }
}
```

Наша оптимизация не ломается *мгновенно*. Тем не менее, она будет продолжать “видеть” старое значение `onClick`, если оно поменяется со временем:

```jsx{6,13-15}
class MyForm extends React.Component {
  state = {
    isEnabled: true
  };
  handleClick = () => {
    this.setState({ isEnabled: false });
    // Сделать что-либо
  }
  render() {
    return (
      <>
        <h1>Hello!</h1>
        <Button color='green' onClick={
          // 🔴 Button проигнорирует изменения в свойстве onClick
          this.state.isEnabled ? this.handleClick : null
        }>
          Press me
        </Button>
      </>
    )
  }
}
```

В этом примере, клик по кнопне должен задизейблить её, но этого не произойдёт, потому что компонент `Button` игнорирует любые изменения в пропсе `onClick`.

Но это может ещё больше запутать если сущность функции сама по себе зависит от чего либо, что со временем может измениться, как `draft.content` в примере:

```jsx{6-7}
  drafts.map(draft =>
    <Button
      color='blue'
      key={draft.id}
      onClick={
        // 🔴 Button игнорирует изменения пропсы onClick
        this.handlePublish.bind(this, draft.content)
      }>
      Publish
    </Button>
  )
```

Хотя `draft.content` может измениться, наш компонет `Button` проигнорирует изменения в свойстве `onClick` и продолжит видеть "первую версию" метода `onClick` с привязанным оригинальным значением `draft.content`.

**И так как нам избежать этой пролемы?**

Я рекомендую избагать ручной имплементации `shouldComponentUpdate` и кастомного сранения в `React.memo()`.
Дефолтное поверхностное сравнение в `React.memo` отразит изменения функции:

```jsx{11}
function Button({ onClick, color, children }) {
  const textColor = slowlyCalculateTextColor(this.props.color);
  return (
    <button
      onClick={onClick}
      className={'Button-' + color + ' Button-text-' + textColor}>
      {children}
    </button>
  );
}
export default React.memo(Button); // ✅ Использует поверхностное сравнение
```

У классов с `PureComponent` похожее поведение.

Это гарантирует, что передача другой функции через пропсы будет всегда работать.

Если вам действительна нужно кастомное сравнение, **убедитесь, что в ней вы не пропустите функции:**

```jsx{5}
  shouldComponentUpdate(prevProps) {
    // ✅ Сравнивает this.props.onClick 
    return (
      this.props.color !== prevProps.color ||
      this.props.onClick !== prevProps.onClick
    );
  }
```

Как я упоминал ранее, легко упустить это проблему в классах, потому что методы часто стабильны (но не всегда - и вот отсюда баги становится тяжело отловить). С хуками ситуация иная:

1. Функции разные *на каждый рендер* поэтому вы столкнётесь с этой проблемой [сразу](https://github.com/facebook/react/issues/14972#issuecomment-468280039).

2. C `useCallback` и `useContext` вы можете [избежать глубокой передачи функций](https://reactjs.org/docs/hooks-faq.html#how-to-avoid-passing-callbacks-down). Это позволяет вам оптимизировать рендер без заботы о функциях.

---

Резюмируем, **Не останавливайте поток данных!**

Всякий раз когда вы используете пропсы и стейт, подумайте о том, что должно произойти, если они изменятся. В большинстве случаев, компонент не должен относится к первому и последующим рендерам по-разному. Это делает его гибиким к изменениям в логике.

С классами легко забыть об изменениях когда используете пропсы и стейт внутри методов жизненного цикла. Хуки подталкивают вас делать правильные вещи - но это потребует некого умственного усилия, если вы ещё не привыкли к хукам.

---

## Принцип 2: всегда будьте готовы к рендеру

React позваляет вам писать код для рендера без особой заботы о времени. Вы описываете как UI *должен* выглядеть в определённый момент времени и React делает это. Пользуйтесь этим преимуществом.

Не пытайтесь вводить ненужные временные предположения (о рендере) в поведение вашего компонента. **Ваш компонент должен быть готов к ре-рендеру в любой момент.**

Можно ли нарушить этот принцип? С React`ом это не так просто - но вы можете сделать это используя легаси метод жизненого цикла `componentWillReceiveProps`:

```jsx{5-8}
class TextInput extends React.Component {
  state = {
    value: ''
  };
  // 🔴 Сбрасывает стейт при каждом рендере своего родителя
  componentWillReceiveProps(nextProps) {
    this.setState({ value: nextProps.value });
  }
  handleChange = (e) => {
    this.setState({ value: e.target.value });
  };
  render() {
    return (
      <input
        value={this.state.value}
        onChange={this.handleChange}
      />
    );
  }
}
```

В этом примере мы держим `value` в локальном стейте, но *так же*
мы получаем `value` из пропсов. Всегда, когда мы получаем новые пропсы, мы сбрасываем `value` в стейте.

**Проблема этого паттерна в том, что он полностью пологается на случайный тайминг.**

Возможно сегодня родитель этого компонента рендерится редко и наш `TextInput` только получает пропсы когда происходит что-то важное, например сохранние формы.

Но завтра возможно вы добавите анимацию к родителю `TexeItem`. Если его родитель будет ре-рендерится чаще, он продолжит ["сносить"](https://codesandbox.io/s/m3w9zn1z8x) стейт своего потомка (`TextInput`). Больше информации вы можетей найти в [“You Probably Don’t Need Derived State”](https://reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html).


**Как мы можем это пофиксить?**

Прежде всего, нам нужно исправить наш образ мылсей. Нам нужно перестать думать о получении пропсов как о чём-то отличном от "рендера". Ре-рендер вызванный из родителя не должен вести себя отлично от ре-рендера вызванного изменением в нашем локальном стейте. **Компоненты должны быть гибкими для того, что бы рендериться реже или чаще, иначе они будут слишком связаны со своими родителями.**

*([Это демо](https://codesandbox.io/s/m3w9zn1z8x) показывает как ре-рендер может сломать хрупкий компонент.)*

Есть несколько [разных](https://reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html#preferred-solutions) [решений](https://reactjs.org/docs/hooks-faq.html#how-do-i-implement-getderivedstatefromprops) для того случая, когда вы *действительно* хотите извлечь стейт из пропсов, обычно лучше использовать либо полностью контролируемый кмопонент:


```jsx
// Вариант 1: Полностью контролируемый кмопонент.
function TextInput({ value, onChange }) {
  return (
    <input
      value={value}
      onChange={onChange}
    />
  );
}
```

Или  вы можете использовать неконтролируемый компонент с key что бы сбросить его:

```jsx
// Вариант 2: Полностью неконтролируемый компонент.
function TextInput() {
  const [value, setValue] = useState('');
  return (
    <input
      value={value}
      onChange={e => setValue(e.target.value)}
    />
  );
}

// Позже мы сможем сбросить весь его локальный стейт изменив key:
<TextInput key={formId} />
```

Ключевое в этом разделе то, что ваш компонент не должен сломаться только потому, что он или его родители часто ре-рендерятся. API React`а упрощает эту задачу, при условии, что вы будете избегать легаси метода `componentWillReceiveProps`.

Для стресс-теста ваших компонентов, вы можете временно добавлять в их родителя следующий код:

```js{2}
componentDidMount() {
  // Не забудьте удалить это немедленно!
  setInterval(() => this.forceUpdate(), 100);
}
```

**Не остовляйте этот код** - это лишь быстрый способ проверить, что будет происходить, когда родитель будет рендериться чаще чем вы ожидаете. Это недолжно сломать потомка!

---

Возможно вы думаете: “Я продолжу сбрасывать стейт при изменении пропсов, но я буду избегать ненужных ре-рендеров с помощью `PureComponent`”.

Этот код должен работать, верно?

```jsx{1-2}
// 🤔 Должны предотвратить ненужный ре-рендер... верно?
class TextInput extends React.PureComponent {
  state = {
    value: ''
  };
  // 🔴 Сбрасывает стейт на каждый рендер родителя
  componentWillReceiveProps(nextProps) {
    this.setState({ value: nextProps.value });
  }
  handleChange = (e) => {
    this.setState({ value: e.target.value });
  };
  render() {
    return (
      <input
        value={this.state.value}
        onChange={this.handleChange}
      />
    );
  }
}
```

По-началу может показаться, что этот компонент решает проблему “сноса” стейта при ре-рендере родителя. В конце концов, если пропсы те же самые, мы просто пропустим обновление и `componentWillReceiveProps` не будет вызван.

Но это дает нам ложное чувство стабильности. **Этот компонент по прежнему не гибок к _действительным_ изменениям пропсов.** Например, если мы добавим *ещё одно* часто меняющиеся свойство, такое как анимированный `стиль`, мы по-прежнему будем “терять” весь стейт:

```jsx{2}
<TextInput
  style={{opacity: someValueFromState}}
  value={
    // 🔴 componentWillReceiveProps в TextInput
    // сбрасывает к этому значению на каждый тик анимации.
    value
  }
/>
```

У этого подхода попрежнему есть недостатки. Мы видим, что такие оптимизации как `PureComponent`, `shouldComponentUpdate`, и `React.memo` не должны были использоваться для контроля *поведения*. Используйте их что бы улучшить *производительность* там, где это может помочь. Если удаление оптимизации _ломает_ компонент, значит он был слишком хрупким и до этого.

Решение здесь то же, что мы описывали ранее. Не относитесть к “получению пропсов” как к особому событию. Избегайте “синхронизации” пропсов и стейта. В большинстве случаев, каждое значение должно быть или полностью под контроллем (через пропсы), или полностью неконтроллируемым (в локальном стейте). Избегайте стейта как производного от пропсов [когда можете](https://reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html#preferred-solutions). **И всегда будьте готовы к рендеру!**

---

## Принцип 3: Компонент не должен быть синглтоном

Иногда мы предпологаем, что определённый компонент будет отображен единожды. Например, панель навигации. Возможно некоторое время так и будет. Тем не менее, это предположение часто вызывает проблемы проектирования, которые проявят себя позже. 

Например, возможно вам нужно вставить анимацию *между* двумя компонентами `Page` при изменении роута - предыдущий `Page` и следующий `Page`. Они оба должны быть смонитированы во время анимации. Тем не менее, вы можете столкнуться с тем, что каждый из этих компонентов предологает, что он единственный компонент `Page` на экране.

Очень легко проверить существование этих проблем. Ради шутки, попробуйте отрендерить ваше приложение дважды:

```jsx{3,4}
ReactDOM.render(
  <>
    <MyApp />
    <MyApp />
  </>,
  document.getElementById('root')
);
```

Покликайте в приложении. (Возможно, вам потребуется немного подкрутить CSS для этого эксперимента).

**Ваше приложение попрежнему действует, как ожидалось?** Или вы наблюдаете странные падения и ошибки? Хорошая идея иногда делать такой стресс-тест со сложными компонентами и убедиться, что несколько таких копий не будут конфликтовать друг с другом.

Примером проблемного паттерна, который я сам писал несколько раз, является “очистка” глобального состояния в `componentWillUnmount`:

```jsx{2-3}
componentWillUnmount() {
  // Сбросить что либо в сторе Redux
  this.props.resetForm();
}
```

Конечно, если на странице находятся два таких компонента, размонтирование (unmount) одного из них может сломать другой. Ресет “глобального” стейта при  *монтировании* (mount) не лучше:

```jsx{2-3}
componentDidMount() {
  // Сбрасывает что либо в сторе Redux
  this.props.resetForm();
}
```

В этом случает *монтирование* второй формы сломает первую.

Эти паттерны - хорошие индикаторы того, где наши компоненты хрупки. ***Показ* или *скрытие* дерева не должно ломать компоненты вне этого дерева.**

Не важно, планируете ли вы рендерить этот компонент дважды или нет, решение этих проблем окупиться в долгосрочной перспективе. Это приведёт вас к более гибкому варианту проектирования.

---

## Принцип 4: Держите локальный стейт изолированным

Рассмотрим компонент социальной сети `Post`. У него есть список тредов -`Comment` (который может быть развёрнут) и инпут `NewComment`.

У React компонентов может быть локальный стейт. Но какой стейт по-настоящему локальный? Содержание каждого поста само по себе является локальным стейтом или нет? Что на счёт списка с комментариями? Или с записью того, какой тред с комментариями развернут? Или что со значением инпута?

Если вы привыкли всё помещать в "стейт менеджер", ответ на этот вопрос может быть непростым. Но есть простой способ решить это.

**Если вы не уверены, является ли какой-то стейт локальным, спросите себя: “Если этот компонент был отрендерен дважды, должно ли это быть отрожено в других копиях?” Если ответ “нет”, вы нашли локальный стейт.**

Например, представьте мы дважды отрендерелили `Post`. Давайте взглянем на разные вещи внутри него которые могли измениться.

* *Контент Post`а.* Мы хотим редактировать пост в одном дереве, что бы обновить его в другом. Следовательно, возможно, лучше **не должно** быть локального стейта у компонента `Post`. (Вместо этого, контент поста лучше разместить в каком-нибудь кэше вроде Apollo, Relay или Redux.)


* *Список комментов.* Здесь схожая ситуация с предыдущей. Мы хотим добавить новый новый коммент в одно дерево комментариев, что бы он так же появился в другом дереве. Идеально, если мы будем использовать какой-то кэш для этого, и он **не должен** быть локальным стейтом нашего Post`а.


* *Какие комменты развёрнуты.* Было бы странным, если бы развернув коммент в одном дереве, мы развернули бы его и в другом. В этом случае мы скорее взаимодействуем с конкретным *UI представлением* компонента `Comment`, чем с абстрактной “сущностью комментария”. Следовательно, флаг “расширения” *должен* быть локальным стейтом компонента `Comment`.

* *Значение нового коммента из инпута.* Будет непонятно, если написание коммента в одном инпуте так же обновило бы инпут в другом дереве. Если только инпуты чётко не сгруппированы вместе, обычно люди ожидают, что они независимы. Значение из инпутов **должно** быть локальным стейтом компонента `NewComment`.

Я не предлагаю догматической интерпретации этих правил. Конечно, в маленьких приложениях вы можете захотеть использовать локальный стейт для всего, включая эти “кэши”. Я только говорю об идеальном пользовательском опыте [из первых принципов](/the-elements-of-ui-engineering/).

**Избегайте создания из локального стейта глобального.** Это подходит к нашей теме “гибкости”: между компонентами меньше неожиданных синхронизаций. Как бонус, это *также* фиксит большое число проблем с производительностю классов (class). “Овер-рендер” намного меньшая проблема, когда ваш стейт находится в правильном месте.

---

## Резюме

Давайте подытожим принципы ещё раз:

1. **[Не останавливайте поток данных](#principle-1-dont-stop-the-data-flow)** Пропсы и стейт могут меняться, но компонент должен обработать эти изменения, когда бы они не произошли.
2. **[Всегда будьте готовы к ререндеру](#principle-2-always-be-ready-to-render)** Компонент не должен сломаться из-за того что он рендерится чаше или реже.
3. **[Компонент не должен быть синглтоном](#principle-3-no-component-is-a-singleton)** Даже если компонент отрендерился только один раз, ваша разработка улучшится, если двойной рендер не сломает ваш компонент. 
4. **[Держите локальный стейт изолированным](#principle-4-keep-the-local-state-isolated)** Думайте о том какой стейт будет локальным для конкретного UI представления - и не поднимайте стейт выше чем необходимо.

**Эти принципы помогут вам писать компоненты которые [оптимизированы для изменений](/optimized-for-change/). Легко можно добавлять, менять и удалять их.**

И самое главное, как только наши компоненты стали гибкими, мы можем вернуться к насущной дилемме - должно ли пропсы быть отсортерованы в алфавитном порядке.
